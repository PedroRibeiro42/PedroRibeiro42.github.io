<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
	<title>Aula Prática #02 - Análise Assintótica</title>
	<link rel="StyleSheet" href="praticas.css" type="text/css">
	<script type="text/javascript" src="latexit.js"></script>
	<meta http-equiv="content-type" content="text/html;charset=utf-8" />
</head>

<body>
  <h3><a href="../index.html">DAA 2020/2021</a> (CC2001) - DCC/FCUP</h3>
  <h1>Aula Prática #02 - Análise Assintótica<br>
    <small><small>(semana de 05/10 a 09/10)</small></small>
  </h1>
<hr>

  <h2>Exercícios para submissão</h2>

  <p>Para efeitos da <a href="../avaliacao.html#classificacao">nota atribuída à resolução de exercícios ao longo do semestre</a>, os exercícios a submeter desta aula são:<br>
     
    <ul>      
      <li><a class="important" href="../problemas/daa005.html">[DAA 005] Bakugans</a> (peso 50%) <span style="color:DarkGreen">(exercício do guião principal)</span>
      <li><a class="important" href="../problemas/daa006.html">[DAA 006] Área de Interseção</a> (peso 50%) <span style="color:DarkGreen">(exercício do guião principal)</span>
      <li><a class="important" href="../problemas/daa007.html">[DAA 007] Um jogo com sequências</a> (peso 25%) <span style="color:DarkSlateBlue">(exercício extra)</span>
      <li><a class="important" href="../problemas/daa008.html">[DAA 008] Um jogo com matrizes</a> (peso 25%) <span style="color:DarkRed">(exercício de desafio)</span>
    </ul>

    <p><b>Prazo de submissão:</b> 25 de Outubro (submeter no <a href="https://mooshak.dcc.fc.up.pt/~daa/">Mooshak de DAA</a>)</p>

  <p><b>Não se esqueçam que qualquer ajuda que tenham recebido de outros colegas deve ser reconhecida nos comentário do programa que submetem.</b><br>Depois do prazo os problemas continuarão disponíveis no Mooshak, mas as submissões não contarão para a sua nota. Relebre que cada aula vale 10% da nota desta componente.<br>
Para um problema contar tem acertar todos os testes. Mesmo que resolva todos os problemas, o máximo numa aula é de 100%.</p>
  
  <hr>
  
 <h3>Conteúdos das teóricas</h3>

  <p>Nesta aula iremos abordar conceitos de <b>análise assintótica</b>. Será por isso conveniente ver o que foi falado nas teóricas:
    <ul>
      <li><a href="../apoio.html#slides">Slides</a> (capítulo "1 - Análise Assintótica")
      <li><a href="../videos/index.html">Vídeos</a>: (vídeos #02, #03, #04 e #05)

    </ul>
  </p>

  <hr>
  
<h3>Notação Assintótica</h3>

  <p>Recorde a definição matemática da notação assintótica:</p>
  
  <p><img width=600 src="bigo_notation.png"><br>
    <img width=600 src="bigo_visual.png"></p>
    
  <hr>

  <h3>Exercício 1) Comparando Funções</h3>

  <p>Para os pares de funções seguintes indique se é verdadeira ou falsa cada uma das seguintes afirmações: <span lang="latex">f(n) \in O(g(n))</span>, <span lang="latex">f(n) \in \Omega(g(n))</span> e <span lang="latex">f(n) \in \Theta(g(n))</span>. Explique sucintamente as suas opções.

  <ol type="a">
    <li><span lang="latex">f(n) =  2n^3 - 10n^2$ ; $g(n) = 25n^2 + 37n</span></li>
    <li><span lang="latex">f(n) =  56$; $g(n) = \log_2 30</span></li>
    <li><span lang="latex">f(n) =  \log_3 n$; $g(n) = \log_2 n</span></li>
    <li><span lang="latex">f(n) =  n^3$; $g(n) = 3^n</span></li>
    <li><span lang="latex">f(n) =  n!$; $g(n) = 2^n</span></li>
    <li><span lang="latex">f(n) =  n!$; $g(n) = n^n</span></li>
    <li><span lang="latex">f(n) =  n \log n + n^2$; $g(n) = n^2</span></li>
    <li><span lang="latex">f(n) =  \sqrt(n)$; $g(n) = \log_2 n</span></li>
    <li><span lang="latex">f(n) =  \log_3 (\log_3 n)$; $g(n) = \log_3 n</span></li>
  </ol>

<p><button title="Dicas" type="button" onclick="if(document.getElementById('spoiler1') .style.display=='none') {document.getElementById('spoiler1') .style.display=''}else{document.getElementById('spoiler1') .style.display='none'}">Mostrar/Esconder Dicas</button></p>
    
	<div id="spoiler1" style="display:none">
	  <ul>
	    <li>O que está no fundo a ser pedido é perceber qual função "domina" a outra, ou seja, qual função cresce mais rapidamente.</li>
	    <li>(a): qual dos polinómios tem maior grau e por isso cresce mais rapidamente?</li>
	    <li>(b): ambos as funções são constantes, ou seja? </li>
	    <li>(c): A base de um logaritmo muda o quê?</li>
	    <li>(d): Uma função polinomial vs uma função exponencial...</li>
	    <li>(e): n!=1*2*3*(...)*(n-1)*n; 2^n=2*2*2*(...)*2; qual é "maior"?</li>
	    <li><i>... ficam algumas para fazerem "sozinhos" :)</i> </li>
	  </ul>	  
	</div>

<p><button title="Dicas" type="button" onclick="if(document.getElementById('spoiler2') .style.display=='none') {document.getElementById('spoiler2') .style.display=''}else{document.getElementById('spoiler2') .style.display='none'}">Mostrar/Esconder alguns exemplos de solução</button></p>
    
  <div id="spoiler2" style="display:none">

    <table border="1">
      <tr>
	<td></td>
	<td></td>
	<td><span lang="latex">f(n) \in O(g(n))</span></td>
	<td><span lang="latex">f(n) \in \Omega(g(n))</span></td>
	<td><span lang="latex">f(n) \in \Theta(g(n))</span></td>	
      </tr>
      <tr>
	<td>(a)</td>
	<td><span lang="latex">f(n) =  2n^3 - 10n^2$ ; $g(n) = 25n^2 + 37n</span></td>
	<td class="center"><font color="red">falso</font></td>
	<td class="center"><font color="green">verdadeiro</font></td>
	<td class="center"><font color="red">falso</font></td>
      </tr>
      <tr>
	<td>(b)</td>
	<td><span lang="latex">f(n) =  56$; $g(n) = \log_2 30</span></td>
	<td class="center"><font color="green">verdadeiro</font></td>
	<td class="center"><font color="green">verdadeiro</font></td>
	<td class="center"><font color="green">verdadeiro</font></td>
      </tr>
      <tr>
	<td>(c)</td>
	<td><span lang="latex">f(n) =  \log_3 n$; $g(n) = \log_2 n</span></td>
	<td class="center"><font color="green">verdadeiro</font></td>
	<td class="center"><font color="green">verdadeiro</font></td>
	<td class="center"><font color="green">verdadeiro</font></td>
      </tr>
      <tr>
	<td>(d)</td>
	<td><span lang="latex">f(n) =  n^3$; $g(n) = 3^n</span></td>
	<td class="center"><font color="green">verdadeiro</font></td>
	<td class="center"><font color="red">falso</font></td>
	<td class="center"><font color="red">falso</font></td>
      </tr>
      <tr>
	<td>(e)</td>
	<td><span lang="latex">f(n) =  n!$; $g(n) = 2^n</span></td>
	<td class="center"><font color="red">falso</font></td>
	<td class="center"><font color="green">verdadeiro</font></td>
	<td class="center"><font color="red">falso</font></td>
      </tr>      
    </table>
    
</div>

  <hr>
  
<h3>Exercício 2) Taxa de crescimento e previsão de tempo de execução</h3>

  <p>Imagine que tem dois programas implementando os algoritmos <i>A</i> e <i>B</i>, ambos tentando resolver o mesmo problema para um input de tamanho <i>n</i>. Quando medimos os seus tempos de execução para diferentes quantidades de input, obtivemos a seguinte tabela:</p>

    <table bgcolor="black" cellpadding="5" cellspacing="1">
      <tr bgcolor="white">
	<td>Algoritmo</td>
	<td><i>n=100</i></td>
	<td><i>n=200</i></td>
	<td><i>n=300</i></td>
	<td><i>n=400</i></td>
	<td><i>n=500</i></td>
      </tr>
      <tr bgcolor="white">
	<td>A</td>
	<td>0.003s</td>
	<td>0.024s</td>
	<td>0.081s</td>
	<td>0.192s</td>
	<td>0.375s</td>
      </tr>
      <tr bgcolor="white">
	<td>B</td>
	<td>0.040s</td>
	<td>0.160s</td>
	<td>0.360s</td>
	<td>0.640s</td>
	<td>1.000s</td>
      </tr>      
    </table>
    
  <ol type="a">
    <li>Qual algoritmo é mais eficiente? Justifique a sua resposta.
    <li>Indique uma estimativa do tempo que cada algoritmo iria demorar para <i>N=5000</i>
  </ol>

<p><button title="Dicas" type="button" onclick="if(document.getElementById('spoiler4') .style.display=='none') {document.getElementById('spoiler4') .style.display=''}else{document.getElementById('spoiler4') .style.display='none'}">Mostrar/Esconder Dicas</button></p>
    
  <div id="spoiler4" style="display:none">
    <p>(a) qual a taxa de crescimento? por exemplo quando duplica o input quanto aumenta o tempo? o que nos diz isso sobre qual a função que o tempo parece estar a seguir (ver slide 44)? qual função é melhor? </p>
    <p>(b) (ver slides 42 e 43)</p>
</div>

  
<hr>

<h3>Exercício 3) Complexidade de ciclos</h3>


  <p>Para cada um dos seguintes pedaços de código a seguir indicados, indique qual a complexidade temporal correcta entre as seguintes hipóteses (explique sucintamente as suas opções):<br>
  <span lang="latex">\Theta(1)</span>, 
  <span lang="latex">\Theta(\log n)</span>, 
  <span lang="latex">\Theta(n)</span>,
  <span lang="latex">\Theta(n \log n)</span>,
  <span lang="latex">\Theta(n^2)</span>,
  <span lang="latex">\Theta(n^2 \log n)</span>,
  <span lang="latex">\Theta(n^3)</span>,
  <span lang="latex">\Theta(n^4)</span>,
  <span lang="latex">\Theta(2^n)</span> ou
  <span lang="latex">\Theta(n!)</span>

  <ol type="a">
    <li>
<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i<span style="color: #333333">=</span><span style="color: #0000DD; font-weight: bold">0</span>; i<span style="color: #333333">&lt;</span>n; i<span style="color: #333333">++</span>)
   <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> j<span style="color: #333333">=</span><span style="color: #0000DD; font-weight: bold">0</span>; j<span style="color: #333333">&lt;</span>n; j<span style="color: #333333">++</span>)
      count<span style="color: #333333">++</span>;
<span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i<span style="color: #333333">=</span><span style="color: #0000DD; font-weight: bold">0</span>; i<span style="color: #333333">&lt;</span>n; i<span style="color: #333333">++</span>)
      count<span style="color: #333333">++</span>;
</pre></div><br>
      
    <li>
 <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i<span style="color: #333333">=</span><span style="color: #0000DD; font-weight: bold">0</span>; i<span style="color: #333333">&lt;</span>n<span style="color: #333333">/</span><span style="color: #0000DD; font-weight: bold">2</span>; i<span style="color: #333333">++</span>)
   <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> j<span style="color: #333333">=</span><span style="color: #0000DD; font-weight: bold">0</span>; j<span style="color: #333333">&lt;</span><span style="color: #0000DD; font-weight: bold">42</span>; j<span style="color: #333333">++</span>)
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> k<span style="color: #333333">=</span>n; k<span style="color: #333333">&lt;</span>n<span style="color: #333333">+</span><span style="color: #0000DD; font-weight: bold">5</span>; k<span style="color: #333333">++</span>)
         count<span style="color: #333333">++</span>;
</pre></div><br>
     
    <li>
<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i<span style="color: #333333">=</span><span style="color: #0000DD; font-weight: bold">0</span>; i<span style="color: #333333">&lt;</span>n; i<span style="color: #333333">+=</span><span style="color: #0000DD; font-weight: bold">2</span>)
   <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> j<span style="color: #333333">=</span><span style="color: #0000DD; font-weight: bold">1</span>; j<span style="color: #333333">&lt;</span>n; j<span style="color: #333333">*=</span><span style="color: #0000DD; font-weight: bold">2</span>)
      count<span style="color: #333333">++</span>;
</pre></div><br>
      
  </ol>

<p><button title="Dicas" type="button" onclick="if(document.getElementById('spoiler5') .style.display=='none') {document.getElementById('spoiler5') .style.display=''}else{document.getElementById('spoiler5') .style.display='none'}">Mostrar/Esconder Dicas</button></p>
    
  <div id="spoiler5" style="display:none">
    <p>(a) qual a complexidade apenas dos dois ciclos iniciais? e do terceiro ciclo? a complexidade de um programa que tem um segmento <i>A</i> seguido de um segmento <i>B</i> é igual a... <i>A+B</i>; portanto neste caso?</p>
    <p>(b) o primeiro ciclo vai até <i>n/2</i> e não <i>n</i>: isso altera a complexidade? o segundo ciclo é executado sempre o mesmo número de vezes (independentemente do n)... e o terceiro ciclo?</p>
    <p>(c) quantas vezes tenho de multiplicar por 2 para chegar a <i>n</i>?</p>
</div>
        
  <hr>

<h3>Exercício 4) Resolvendo um problema (solução <i>naive</i> não passa por causa da sua complexidade )</h3>
  
<p><a href="https://mooshak.dcc.fc.up.pt/~daa/"><img src="mooshak.gif" border="0"></a><br>
  Agora que já fizemos alguns exercícios "em papel", voltemos ao "conforto" das implementações. Deve começar por ler o enunciado com atenção.

  <ul>
    <li>Resolva e submeta o problema <a class="important" href="../problemas/daa005.html">[DAA 005] Bakugans</a></li>
    </ul>

<p><b>i) Uma solução naive em O(N*F)</b><br>
  Comece por implementar a solução "óbvia": para cada foto fazer um ciclo entre <b>A<sub>i</sub></b> e <b>B<sub>i</sub></b> e somar as energias dos bakugans correspondentes.<br>
	Qual a complexidade desta solução? <b>O(N*F)</b>, pois para cada foto <i>F</i> faz um ciclo que no pior caso é de tamanho <i>N</i>.<br>
	Submeta para verificar que não passa no tempo, sendo que nalguns casos obterá <span style="color:red">"Time Limit Exceeded"</span> (neste problema o limite no Mooshak está em 2s)<br>
	Isto acontece porque no pior caso N=F=200000, e 200000<sup>2</sup> é demasiado! (ver slide 48)</p>

<p><b>ii) Medindo o tempo de execução</b><br>
  Experimente na sua máquina correr a solução trivial com os casos que a seguir lhe damos, e meça o tempo de execução (<tt>daa005_X.txt</tt> contém um caso com N=F=X):<br>
Inputs: <a class="important" href="daa005_25000.txt">daa005_25000.txt</a>
<a class="important" href="daa005_50000.txt">daa005_50000.txt</a> |
<a class="important" href="daa005_100000.txt">daa005_100000.txt</a> |
<a class="important" href="daa005_200000.txt">daa005_200000.txt</a><br>

<p>Exemplo de execução numa shell:  <span class="shell">time programa < daa005_X.txt > output.txt</span><br><i>(assumindo que o comando para executar o seu código é "programa")</i></p> 

<p>Consegue perceber a taxa de crescimento do seu programa? Consegue estimar quanto tempo demoraria para por exemplo N=F=1 milhão?

<p><b>iii) Melhorando a solução para O(N+F)</b><br>
Um conceito muito interessante é o de <a href="http://en.wikipedia.org/wiki/Prefix_sum">"prefix sums"</a>, ou
como se costuma dizer por cá, "somas acumuladas" (ou
cumulativas).</p>

<p>Imaginemos por exemplo um array de números. As somas acumuladas são
as somas totais até à posição respectiva. Por exemplo:

<pre>
<b>     Posição <i>i</i>:</b>  0  1  2  3  4  5  6  7
<b>         Array:</b>     3  7  2  4  5  7  6
<b>Soma acumulada:</b>  0  3 10 12 16 21 28 34
</pre>

<p>Se tivermos armazenada a soma acumulada, que se pode calcular
linearmente - <b>O(N)</b>- descobrir a soma de um dado intervalo
faz-se em tempo constante - <b>O(1)</b>. Por exemplo, se <i>ac[]</i>
guardar a soma acumulada, a soma entre as posições <i>a</i> e <i>b</i>
é igual a <i>ac[b]-ac[a-1]</i>.

<p>Isto pode ser usado para ajudar a resolver muitos problemas de
forma mais eficiente, incluindo este problema dos Bakugans. Se as somas acumuladas forem calculadas, podemos responder a cada foto em <b>O(1)</b>, o que faz com que a complexidade geral do programa fique a ser O(N+F), pois temos a leitura das energias, seguida da leitura das fotos, com resposta então em tempo constante para cada uma.</p>

<table>
  <tr>
    <td bgcolor="#ffcccc"><b><span style="color:#990000;">INFORMAÇÃO IMPORTANTE PARA QUEM USA JAVA:</span></b><br>
      Como pode ser preciso ler 600 mil inteiros (energias e fotos) e escrever 200 mil inteiros (as somas), para submeter com sucesso este problema será necessário ter <a href="fastio.html">input/output rápido em Java</a>.<br>
No Mooshak iremos providenciar classes com esse propósito, pelo que devem ler a página de ajuda correspondente: <a href="fastio.html"> Leitura e Escrita Rápida (C vs C++ vs Java)</a></b>
    </td>      
  </tr>
</table>

<hr>

<h3>Exercício 5) Dividir para conquistar!</h3>
  
<p><a href="https://mooshak.dcc.fc.up.pt/~daa/"><img src="mooshak.gif" border="0"></a><br>
  Vamos agora explorar outro conceito muito útil que abordado nas teóricas, resolvendo um com o paradigma de <a href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm">dividir para conquistar</a>. Deve começar por ler o enunciado com atenção.

  <ul>
    <li>Resolva e submeta o problema <a class="important" href="../problemas/daa006.html">[DAA 006] Área de interseção</a></li>
    </ul>

<p>Uma possibilidade seria resolver o problema de forma analítica. Existem contudo muitos tipos de casos a considerar...</p>

<p><img src="cq1.png">

<p>Vamos resolver este problema de forma uma forma completamente diferente, puramente algorítmica, usando então a ideia de dividir para conquistar. Vamos começar por pensar em quais são os casos mais fáceis. Se uma figura está completamente dentro da outra, a interseção é toda a sua área! Por outro lado, se está completamente fora, a interseção é 0:</p>
  
<p><img src="cq2.png">

<p>O que fazer quando não acontecer um destes casos fáceis? Se queremos dividir para conquistar, temos de pensar em dividir. Se dividirmos o quadrado em quatro partes, temos agora quatro novos quadrados mais pequenos, onde o que queremos saber é precisamente um subproblema igual ao inicial! 

<p><img src="cq3.png" width="650">

<p>Imagine-se que o caso era o representado em cima. O quadrado não é um caso simples, logo dividimos em quatro e chamamos a mesma recursão. Aqui, Q1, Q2 e Q3 são casos simples (completamente fora do círculo) e por isso devolvem 0. No caso de Q4 temos que novamente dividir em quatro. Dessa nova divisão, Q9 é simples (completamente dentro) e outros subquadrados não, pelo que iriamos novamente dividir em quatro recursivamente.

<p>Quando é que devemos parar de dividir? Em cada passo os quadrados têm metade do lado do quadrado inicial, mas podem ficar "infinitamente" mais pequenos enquanto estivemos perto da borda do círculo... O que podemos fazer é parar... quando estivermos "satisfeitos" com a precisão obtida! Quanto mais fundo formos na recursão, mais preciso será o resulado, mas mais tempo demorará a recursão para terminar.

<p>No final de tudo, deverá portanto ter uma função recursiva semelhante a esta:</p>

<pre class="codigo">
<b>intersecao</b>(x1, x2, y1, y2) <font color="#666666">// quadrado de (x1,y1) até (x2,y2)</font>
   <b>Se</b> (uma figura está garantidamente fora da outra) <b>então</b> <b>retornar</b> 0
   <b>Se</b> (quadrado dentro do círculo) <b>então</b> <b>retornar</b> área do quadrado
   <b>Se</b> (círculo dentro do quadrado) <b>então</b> <b>retornar</b> área do círculo
   area &leftarrow; 0
   <b>Se</b> (quadrado for ainda grande o suficiente) <b>então</b> 
      area &leftarrow; area + intersecao(subquadrado superior esquerdo)
      area &leftarrow; area + intersecao(subquadrado superior direito)
      area &leftarrow; area + intersecao(subquadrado inferior esquerdo)
      area &leftarrow; area + intersecao(subquadrado inferior direito)
   <b>retornar</b> area
</pre>

<p>Implemente esta solução e submeta-a no Mooshak (deverá obter 100 pontos).
  
  <hr>

  <h3>[Exercício extra 1] As minhas primeiras provas</h3>

  <p>Para consolidar os conhecimentos de notação assintótica, prove a verdade ou falsidade das seguintes afirmações, usando a definição matemática (dada em cima), :

<ol type="a">
  <li><span lang="latex">2^{n+2} \in O(2^n)</span>
  <li><span lang="latex">2^{2n} \in O(2^n)</span>
  <li><span lang="latex">f(n) \in O(g(n)) \implies g(n) \in O(f(n))</span>
  <li><span lang="latex">f(n) \in O(g(n)) \implies g(n) \in \Omega(f(n))</span>
  <li><span lang="latex">(n+2)^2 \in \Theta(n^2)</span>
</ol>

<p><button title="Dicas" type="button" onclick="if(document.getElementById('spoiler3') .style.display=='none') {document.getElementById('spoiler3') .style.display=''}else{document.getElementById('spoiler3') .style.display='none'}">Mostrar/Esconder um exemplo de solução</button></p>
    
  <div id="spoiler3" style="display:none">
    <p>
      <ul><li> Alínea (a)<br>
	  2<sup>n+2</sup> = 2<sup>n</sup> * 2<sup>2</sup> = 4*2<sup>n</sup><br>
	  Logo por isto já vemos que de facto 2<sup>n+2</sup> pertence a Θ(2<sup>n</sup>).
	  Para mostrar que é verdade que 2<sup>n+2</sup> pertence a O(2<sup>n</sup>) basta, como diz a definição, arranjar duas constantes <b>n<sub>0</sub></b> e <b>c</b> tal que <i>f(n) &le; c*g(n) para n &ge; n<sub>0</sub></i></b><br>
Basta escolher <b>n<sub>0</sub>=1</b> e <b>c=4</b>, por exemplo, para isto ser trivialmente verdade.
      </ul>
    </p>
  </div>

<hr>

<h3>[Exercício extra 2] Complexidade de funções recursivas</h3>

  <p>Para cada uma dos seguintes funções recursivas indicadas, assumindo que chama no início <i>f(v, 0, n-1)</i>, indique qual a recorrência que representa o seu tempo de execução, qual a complexidade temporal (notação <span lang="latex">\Theta</span>) e justifique essa complexidade desenhando a respetiva árvore de recorrência (com os pesos associados a cada nível). Consegue perceber o que calculam as funções?


  <ol type="a">
    <li>
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">f</span>(<span style="color: #333399; font-weight: bold">int</span> v[], <span style="color: #333399; font-weight: bold">int</span> start, <span style="color: #333399; font-weight: bold">int</span> end) {
    <span style="color: #008800; font-weight: bold">if</span> (start<span style="color: #333333">==</span>end) <span style="color: #008800; font-weight: bold">return</span> v[start];
    <span style="color: #008800; font-weight: bold">return</span> v[start] <span style="color: #333333">+</span> f(v, start<span style="color: #333333">+</span><span style="color: #0000DD; font-weight: bold">1</span>, end);
}
</pre></div><br>

    <li>
      <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">f</span>(<span style="color: #333399; font-weight: bold">int</span> v[], <span style="color: #333399; font-weight: bold">int</span> start, <span style="color: #333399; font-weight: bold">int</span> end) {
    <span style="color: #008800; font-weight: bold">if</span> (start<span style="color: #333333">==</span>end) <span style="color: #008800; font-weight: bold">return</span> v[start];
    <span style="color: #333399; font-weight: bold">int</span> middle <span style="color: #333333">=</span> (start<span style="color: #333333">+</span>end)<span style="color: #333333">/</span><span style="color: #0000DD; font-weight: bold">2</span>;
    <span style="color: #008800; font-weight: bold">return</span> f(v, start, middle) <span style="color: #333333">+</span> f(v, middle<span style="color: #333333">+</span><span style="color: #0000DD; font-weight: bold">1</span>, end);
}
      </pre></div><br>
  </ol>

<p><button title="Dicas" type="button" onclick="if(document.getElementById('spoiler6') .style.display=='none') {document.getElementById('spoiler6') .style.display=''}else{document.getElementById('spoiler6') .style.display='none'}">Mostrar/Esconder Dicas</button></p>
    
  <div id="spoiler6" style="display:none">
    <p>Ver slides 67 a 78 e ver o <a href="https://www.youtube.com/watch?v=KbR8qbBjvi4">vídeo #05</a> da teórica (18m30s a 43m15) :)</p>
</div>

<hr>

<h3>[Exercício extra 3] Dividir para Conquistar II</h3>


  <p><a href="https://mooshak.dcc.fc.up.pt/~daa/"><img src="mooshak.gif" border="0"></a><br>Tem disponível mais um problema para submissão onde a complexidade é importante e onde pode testar os seus conhecimentos na paradigma de de dividir para conquistar.

  <ul>
    <li>Resolva e submeta o problema <a class="important" href="../problemas/daa007.html">[DAA 007] Um jogo com sequências</a></li>
    </ul>

  <p>Este problema já foi usado em Estruturas de Dados em 2019/2020 (<a href="https://www.dcc.fc.up.pt/~pribeiro/aulas/edados1920/praticas/aula09.html">ver exercício 4 da aula #09</a>). Se for ver essa explicação poderá ver explicadas soluções com complexidade cúbida, quadrática e linear.</p>

  <p>A ideia aqui é implementar uma solução <b>O(n log n)</b> que usa a ideia de dividir para conquistar. Imagine que inicialmente tem uma sequência S. Podemos dividir a sequência em duas metades S1 e S2:

    <p><img src="sms.png">
	
    <p>Seja a subsequência de maior soma indicada pela sigla <b>SMS</b>. Então, podemos dizer que SMS(S) é igual ao máximo entre:</p>
      <ol type="i">
	<li>SMS(S1)
	<li>SMS(S2)
	<li>Melhor subsequência que começa em S1 e termina em S2
      </ol>

    <p>SMS(S1) e SMS(S2) são subproblemas do mesmo tipo do primeiro e podem ser resolvidos chamando a mesma função recursivamente!</p>

    <p>Como calcular (iii)? Se pensar bem, basta considerar a melhor sequência que termina no último elemento de S1 e juntá-la à melhor sequência que começa no primeiro elemento de S2! É fácil obter isto em tempo linear (ex: para saber a melhor sequência desde o início de S2 basta começar no primeiro elemento e ir adicionando elementos, guardando o melhor).</p>

    <p>O seu código deverá portanto no final ter uma função recursiva semelhante a esta:</p>

<pre class="codigo">
<b>sms</b>(v, a, b) <font color="#666666">// subsequência de maior soma do array v[] entre as posições a e b</font>
   <b>Se</b> (a==b) <b>então</b> <b>retornar</b> v[a]
   meio &leftarrow; (a+b)/2
   best1 &leftarrow; <b>sms</b>(v, a, meio)
   best2 &leftarrow; <b>sms</b>(v, meio+1, b)
   best3 &leftarrow; melhor sequência que começa na primeira metade e termina na segunda metade
   <b>retornar</b> <b>maximo</b>(best1, best2, best3)
</pre>

<p>A complexidade será emelhante ao mergesort, com a recorrência a ser <b>T(n) = 2T(n/2) + &Theta;(n)</b> (que como vimos nas teóricas dá <b>&Theta;(n log n)</b>. Note que para isto acontecer best3 tem de ser calculado em tempo linear, como atrás descrito.</p>

<p>Implemente esta solução e submeta-a no Mooshak (deverá obter 100 pontos).

  <table>
  <tr>
    <td bgcolor="#ffcccc"><b><span style="color:#990000;">INFORMAÇÃO IMPORTANTE PARA QUEM USA JAVA:</span></b><br>
      Como pode ser preciso ler 200 mil inteiros (energias e fotos), para submeter com sucesso este problema será necessário ter <a href="fastio.html">input/output rápido em Java</a>.<br>
No Mooshak iremos providenciar classes com esse propósito, pelo que devem ler a página de ajuda correspondente: <a href="fastio.html"> Leitura e Escrita Rápida (C vs C++ vs Java)</a></b>
    </td>      
  </tr>
</table>

  
    
  <hr>

<h3>Exercício de Desafio</h3>

<p>Todas as semanas vou colocar disponível pelo menos mais um exercício um pouco mais desafiante.</p>

<p>Para esta semana o desafio tem a ver com a eficiência algorítmica e como desenhar um algoritmo que seja <b>O(n<sup>3</sup>)</b> para o seguinte problema, que está disponível para submissão no <a href="https://mooshak.dcc.fc.up.pt/~daa/">Mooshak</a>:

  <ul>
    <li class="big"><a class="important" href="../problemas/daa008.html">[DAA 008] Um jogo com matrizes</a>
  </ul>

<p>Como pode usar e extender as ideias que já aprendou ou recordou nesta aula? Como este é um problema de desafio, não vou para já dar mais <a href="https://www.youtube.com/watch?v=dQw4w9WgXcQ">dicas</a> :)</p>

<p>Se já tiverem feito tudo e estiverem "presos" neste, e quiserem mesmo fazer o desafio, podem contactar-me para eu "dosear" as dicas, sabendo que este problema é substancialmente mais difícil os outros desta aula.

<hr>
<p class="footer">Pedro Ribeiro (DCC/FCUP) / Última actualização: <b><script language="Javascript">document.write(document.lastModified )</script></p>
</body>

</html>
